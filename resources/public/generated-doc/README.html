<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Buttle README</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Buttle</span> <span class="project-version">0.1.4-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>Buttle README</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buttle</span></div></div></li><li class="depth-2 branch"><a href="buttle.connection-pool-data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection-pool-data-source</span></div></a></li><li class="depth-2 branch"><a href="buttle.data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data-source</span></div></a></li><li class="depth-2 branch"><a href="buttle.driver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver</span></div></a></li><li class="depth-2 branch"><a href="buttle.driver-manager.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver-manager</span></div></a></li><li class="depth-2 branch"><a href="buttle.event.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>event</span></div></a></li><li class="depth-2 branch"><a href="buttle.proxy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proxy</span></div></a></li><li class="depth-2 branch"><a href="buttle.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="buttle.xa-data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xa-data-source</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#buttle-readme" name="buttle-readme"></a>Buttle README</h1>
<h2><a href="#what-is-it-" name="what-is-it-"></a>What is it?</h2>
<p><em>Buttle</em> is a proxying JDBC driver with hooks.</p>
<p><strong>proxies</strong></p>
<p><em>Buttle</em> ships a <code>java.sql.Driver</code> which delegates <code>connect</code> calls to a backing (or <em>real</em>) driver (like <code>org.postgresql.Driver</code>). The <em>Buttle</em> driver wraps a <em>Buttle</em> proxy around the returned <code>java.sql.Connection</code>. The <em>Buttle</em> proxy then (recursivly) does the same to the wrapped instance – i.e. it wraps a <em>Buttle</em> proxy around the return value of delegated method calls.</p>
<p>The effect of this is that the application which is using the <em>Buttle</em> <code>java.sql.Driver</code> will ever only call JDBC API methods through a <em>Buttle</em> proxy (e.g. for <code>java.sql.Statement</code> and <code>java.sql.ResultSet</code>).</p>
<p><em>Buttle</em> proxies are only constructed for methods (i.e. their returned values) that have interface-typed declared return types.</p>
<p><strong>hooks</strong></p>
<p><em>Buttle</em> proxies delegate calls to the backing JDBC driver’s instances through <code>buttle.proxy/handle</code> multi method. Via <code>buttle.proxy/def-handle</code> users can <em>inject/hook</em> their own multi-method implemenations (per interface/method) into the delegation mechanism. See example in <code>examples/buttle/examples/open_tracing.clj</code> and <code>examples/buttle/examples/handle.clj</code>.</p>
<p><strong>events</strong></p>
<p><em>Buttle</em> proxies also create <em>events</em> for every method invocation and completion incl. when an <code>Exception</code> is thrown (see <code>buttle.proxy/handle-default</code>).</p>
<p>These events include info about</p>
<ul>
  <li>timestamp of the event</li>
  <li>duration (for completion/<code>Exception</code>)</li>
  <li>stacktrace (for exceptions)</li>
  <li>invoked class/method</li>
  <li>arguments</li>
  <li>returned value/<code>Exception</code></li>
</ul>
<p>Events (see <code>event.clj</code>) are communicated through a <code>clojure.core.async/mult</code> that users can <code>tap</code> onto to receive the events. See usage example in <code>examples/buttle/examples/event_channel.clj</code>.</p>
<p><strong>references</strong></p>
<p>Similar things have been done before:</p>
<ul>
  <li><a href="https://www.javaspecialists.eu/archive/Issue136.html">https://www.javaspecialists.eu/archive/Issue136.html</a></li>
  <li><a href="https://jaxenter.de/jdbc-treiber-selbstgebaut-java-trickkiste-636">https://jaxenter.de/jdbc-treiber-selbstgebaut-java-trickkiste-636</a></li>
  <li><a href="http://jamonapi.sourceforge.net/jamon_sql.html">http://jamonapi.sourceforge.net/jamon_sql.html</a></li>
  <li><a href="https://github.com/arthurblake/log4jdbc">https://github.com/arthurblake/log4jdbc</a></li>
  <li><a href="https://p6spy.readthedocs.io/en/latest/index.html">https://p6spy.readthedocs.io/en/latest/index.html</a></li>
  <li><a href="http://sfleiter.github.io/blog/2013/12/08/jboss-datasource-proxy-with-log4jdbc-log4j2/">http://sfleiter.github.io/blog/2013/12/08/jboss-datasource-proxy-with-log4jdbc-log4j2/</a></li>
</ul>
<h2><a href="#what-to-use-it-for-" name="what-to-use-it-for-"></a>What to use it for?</h2>
<p>Use it for</p>
<ul>
  <li>
  <p>testing</p></li>
  <li>
  <p>troubleshooting</p></li>
  <li>
  <p>debugging</p></li>
  <li>
  <p>performance measurements</p></li>
  <li>
  <p>application monitoring</p></li>
</ul>
<p><strong>Note</strong>: I haven’t done any measurements on how much <em>Buttle</em> hurts the performance.</p>
<h2><a href="#using-buttle" name="using-buttle"></a>Using <em>Buttle</em></h2>
<ul>
  <li>
  <p>You can download <em>Buttle</em> UBERJAR releases and snapshots from  Clojars [1] and use it in <strong>non-Clojure</strong> contexts like you would  use any other JDBC driver. This UBERJAR includes the Clojure core  lib and <code>clojure.core.async</code>. That’s why you should not mix it with  a classpath that contains a seperate Clojure core lib. You find  examples for this use-case down below.</p></li>
  <li>
    <p>For Clojure projects you can use <em>Buttle</em> as a lib/dependency  (e.g. via Leiningen). Just put the following in your <code>project.clj</code>  (see <code>use-buttle</code> [2] for a simple example).</p>
    <pre><code>:dependencies [[buttle "0.1.1-SNAPSHOT"] ,,,]
</code></pre>
  </li>
</ul>
<p>[1] <a href="https://clojars.org/repo/buttle/buttle/">https://clojars.org/repo/buttle/buttle/</a><br />[2] <a href="https://github.com/henrik42/use-buttle">https://github.com/henrik42/use-buttle</a> </p>
<h2><a href="#extending-buttle-at-runtime" name="extending-buttle-at-runtime"></a>Extending <em>Buttle</em> at runtime</h2>
<p>There are two ways to <em>hook into Buttle</em>:</p>
<p><strong>events</strong>: receive events from <em>Buttle</em> through  <code>buttle.event/event-mult</code> like this:</p>
<pre><code>(let [ch (clojure.core.async/chan)]
  (clojure.core.async/tap buttle.event/event-mult ch)
  (clojure.core.async/go
   (loop []
     (when-let [e (clojure.core.async/&lt;! ch)]
       (println e) ;; do something with the event
       (recur)))))
</code></pre>
<p><strong>multi method</strong>: <em>inject</em> your own proxy for <em>target</em>  interfaces/methods. This acts like an AOP advice/proxy. Note that in  this case you have to take care to send events if you need that (see  <code>buttle.proxy/handle-default</code>).</p>
<p>So you can (re-) register the <code>buttle.proxy/handle :default</code>.</p>
<pre><code>(defmethod buttle.proxy/handle :default [the-method target-obj the-args]
  (do-some-thing-with-call the-method target-obj the-args))
</code></pre>
<p>And you can register multi method implementation for just specific interfaces, methods or a combination of these (see <code>test/buttle/proxy_test.clj</code>, <code>examples/buttle/examples/open_tracing.clj</code> and <code>examples/buttle/examples/handle.clj</code> for more examples):</p>
<pre><code>(buttle.proxy/def-handle [java.sql.Connection :buttle/getCatalog] [the-method target-obj the-args]
  (do-some-thing-with-call the-method target-obj the-args))
</code></pre>
<p><code>do-some-thing-with-call</code> could look like this:</p>
<pre><code>(defn invoke-with-logging [the-method target-obj the-args]
  (println (format "buttle.examples.handle: INVOKE %s"
                   (pr-str [the-method target-obj (into [] the-args)])))
  (let [r (try
            (proxy/handle-default the-method target-obj the-args)
            (catch Throwable t
              (do
                (println (format "buttle.examples.handle: THROW %s : %s"
                                 (pr-str [the-method target-obj (into [] the-args)]) (pr-str t)))
                (throw t))))]
    (println (format "buttle.examples.handle: RETURN %s --&gt; %s"
                     (pr-str [the-method target-obj (into [] the-args)]) (pr-str r)))
    r))
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<h3><a href="#squirrel" name="squirrel"></a>SQuirreL</h3>
<p><strong>(1)</strong> In <code>squirrel-sql.bat</code> add system property <code>buttle.user-file</code> to java call:</p>
<pre><code>set BUTTLE="-Dbuttle.user-file=&lt;path-to&gt;/buttle/examples/handle.clj"
java [...] %BUTTLE% [...]
</code></pre>
<p><strong>(2)</strong> In the GUI add a <em>Driver</em> with <em>extra classpath</em>  <code>&lt;path-to&gt;/buttle-driver.jar</code> and class <code>buttle.jdbc.Driver</code>.</p>
<p><strong>(3)</strong> In the GUI add an <em>Alias</em> with URL (replace <code>&lt;user&gt;</code> and  <code>&lt;password&gt;</code>). Text following <code>jdbc:buttle:</code> will be  <code>read</code>/<code>eval</code>’ed as Clojure map form.</p>
<pre><code>jdbc:buttle:{:user "&lt;user&gt;" :password "&lt;password&gt;" :target-url "jdbc:postgresql://127.0.0.1:6632/postgres"}
</code></pre>
<h3><a href="#wildfly" name="wildfly"></a>Wildfly</h3>
<p>When using <em>Buttle</em> in Wildfly (either <em>domain</em> mode oder <em>standalone</em>) you can either include it in your application (but usually JDBC drivers are not included in the main app) or you can deploy it as a <em>module</em> (tested with Wildfly 12.0.0.Final).</p>
<p>For this you have to:</p>
<ul>
  <li>define a <code>&lt;module&gt;</code></li>
  <li>define a <code>&lt;driver&gt;</code></li>
  <li>define a <code>&lt;datasource&gt;</code> (or <code>&lt;xa-datasource&gt;</code>; see below)</li>
</ul>
<p><strong>(1)</strong> Define <code>&lt;module&gt;</code>: put this into  <code>&lt;wildfly-root&gt;/modules/buttle/main/module.xml</code>. You may have to  adjust <code>path</code> to <em>Buttle</em>’s JAR filename. Note that you have to  include <code>&lt;dependencies&gt;</code> for the <code>javax.api</code> base module and the  JDBC driver you want to wrap (Postgres in this case). Otherwise  <em>Buttle</em> won’t be able to <em>see</em> the JDBC driver’s classes.</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;module xmlns="urn:jboss:module:1.1" name="buttle"&gt;

  &lt;resources&gt;
    &lt;resource-root path="buttle-driver.jar"/&gt;
  &lt;/resources&gt;

  &lt;dependencies&gt;
    &lt;module name="postgres"/&gt;
    &lt;module name="javax.api"/&gt; 
  &lt;/dependencies&gt;

&lt;/module&gt; 
</code></pre>
<p><strong>(2)</strong> Define <code>&lt;driver&gt;</code>: Note that Wildfly does not need to know  <em>Buttle</em>’s driver class (<code>buttle.jdbc.Driver</code>). It relies on  <em>Buttle</em> being loaded via SPI  (<code>META-INF/services/java.sql.Driver</code>). Wildfly then finds the  <em>Buttle</em> driver via <code>DriverManager/getConnection</code>.</p>
<pre><code>&lt;drivers&gt;
  &lt;driver name="buttle-driver" module="buttle"/&gt;
&lt;/drivers&gt;
</code></pre>
<p><strong>(3)</strong> Define <code>&lt;datasource&gt;</code>: in this example there is no extra  Postgres <code>&lt;datasource&gt;</code>/<code>&lt;driver&gt;</code> entry so Wildfly will not load  the Postgres JDBC driver for us. Therefore we put <code>:class-for-name
  "org.postgresql.Driver"</code> into the <em>Buttle</em> URL. Now <em>Buttle</em> loads  the JDBC driver’s class and usually these will register themselves  with the <code>DriverManager</code>. After that <em>Buttle</em> can connect to  Postgres through the <code>DriverManager</code> (see section <strong>A note on  authentication</strong> below for details on how authentication works with  <em>Buttle</em>).</p>
<pre><code>&lt;datasource jndi-name="java:/jdbc/buttle-ds" pool-name="buttle-ds"&gt;
    &lt;driver&gt;buttle-driver&lt;/driver&gt;
    &lt;connection-url&gt;
        jdbc:buttle:{
            :user "&lt;user&gt;"
            :password "&lt;password&gt;"
            :class-for-name "org.postgresql.Driver"
            :target-url "jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;db-id&gt;"}
    &lt;/connection-url&gt;
&lt;/datasource&gt;
</code></pre>
<p>Note: if you define a <code>&lt;datasource&gt;</code> with <code>&lt;connection-url&gt;</code> then Wildfly will create a <code>javax.sql.DataSource</code> <strong>datasource proxy</strong> that uses the <code>java.sql.DriverManager</code> API to lookup the JDBC driver and open connections. So in the example above it will effectively use <code>buttle.jdbc.Driver</code> and not <code>buttle.jdbc.DataSource</code>. Below you find an example which involves <code>buttle.jdbc.DataSource</code>.</p>
<p>Instead of loading the class explicitly you can just use a class literal with some arbitrary key in the map – like this:</p>
<pre><code>    &lt;connection-url&gt;
        jdbc:buttle:{
            :user "&lt;user&gt;"
            :password "&lt;password&gt;"
            :_ org.postgresql.Driver
            :target-url "jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;db-id&gt;"}
    &lt;/connection-url&gt;
</code></pre>
<p>If you rather have Wildfly load the Postgres driver you just add a <code>&lt;driver&gt;</code> entry for Postgres. In this case you do not need the <code>:class-for-name</code>/class-literal entry.</p>
<pre><code>&lt;drivers&gt;
  &lt;driver name="buttle-driver" module="buttle"/&gt;
  &lt;driver name="postgresql" module="postgres"/&gt;
&lt;/drivers&gt;
</code></pre>
<p>There is yet another way to make Wildfly load Postgres JDBC driver. Instead of adding the <code>&lt;driver&gt;</code> you can add <code>services="import"</code> to the <code>module/dependencies</code>:</p>
<pre><code>&lt;module name="postgres" services="import"/&gt;
</code></pre>
<p>Since <em>Buttle</em> itself doesn’t give you much functionality beyond delegation logic you probably want to define <code>buttle.user-file</code> system property to have <em>Buttle</em> load your <em>hook code</em>:</p>
<pre><code>&lt;system-properties&gt;
  &lt;property name="buttle.user-file" value="&lt;path-to&gt;/buttle-user-file.clj" boot-time="true"/&gt;
&lt;/system-properties&gt;
</code></pre>
<h4><a href="#using" name="using"></a>Using <code>buttle.jdbc.DataSource</code></h4>
<p>Depending on how you define the <code>&lt;datasource&gt;</code> Wildfly will use the <code>java.sql.DriverManager</code>/<code>java.sql.Driver</code> (see above) or <code>javax.sql.DataSource</code> API. The following example shows how to make Wildfly use the <code>javax.sql.DataSource</code> API:</p>
<pre><code>&lt;datasource jndi-name="java:jboss/datasources/buttle-ds" pool-name="buttle-ds"&gt;
      &lt;driver&gt;buttle-driver&lt;/driver&gt;
      &lt;datasource-class&gt;buttle.jdbc.DataSource&lt;/datasource-class&gt;
      &lt;security&gt;
          &lt;user-name&gt;postgres-user&lt;/user-name&gt;
          &lt;password&gt;postgres-password&lt;/password&gt;
      &lt;/security&gt;
      &lt;connection-property name="DelegateSpec"&gt;
          {:delegate-class org.postgresql.ds.PGSimpleDataSource :url "jdbc:postgresql://127.0.0.1:6632/postgres"}
      &lt;/connection-property&gt;
&lt;/datasource&gt;
</code></pre>
<p>Note that for <code>connection-property</code> there <strong>must be no linebreak</strong> in the element value!</p>
<h4><a href="#a-note-on-authentication" name="a-note-on-authentication"></a>A note on authentication</h4>
<p>Usually JEE containers let you define a datasource and with it supply authentication credentials (e.g. username and password). For Wildfly this is done through the <code>security</code> element:</p>
<pre><code>    &lt;xa-datasource jndi-name="java:/jdbc/postgres-xa" pool-name="postgres-xa"&gt;
      &lt;driver&gt;postgres-driver&lt;/driver&gt;
      &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
      &lt;security&gt;
        &lt;user-name&gt;postgres-user&lt;/user-name&gt;
        &lt;password&gt;postgres-password&lt;/password&gt;
      &lt;/security&gt;
      &lt;xa-datasource-property name="Url"&gt;jdbc:postgresql://127.0.0.1:6632/postgres&lt;/xa-datasource-property&gt;
    &lt;/xa-datasource&gt;
</code></pre>
<p>For IBM WAS you enter <strong>security aliases</strong> (see below).</p>
<p>Then when your application needs a JDBC connection it calls <code>javax.sql.DataSource.getConnection()</code> on the datasource which it usually retrieves from JNDI. Your app rarely calls <code>javax.sql.DataSource.getConnection(String username, String password)</code> since no-one wants to give authentication credentials to your app. That’s why it is given to the JEE container only.</p>
<p>When calling <code>getConnection()</code> your app will be talking to a <code>javax.sql.DataSource</code> <strong>datasource proxy</strong> that the JEE container puts between your code and the <em>real</em> datasource (which may even be an XA-datasource really; like in the example shown above). If you have given authentication credentials explicitly to the container (like shown above) then the container’s <strong>datasource proxy</strong> will call <code>javax.sql.DataSource.getConnection(String username, String password)</code> on the <em>real</em> datasource when delegating your call and thus supplying the configured authentication credentials for connecting to the database.</p>
<p>Instead of giving authentication credentials explicitly to the container (like shown above) you can usually set some of the <em>real</em> datasource’s Java-Beans property values to give it username and password.</p>
<p>Note that in this case the container has no explicit knowledge about the details on how and what authentication credentials you give to the datasource. And it depends on the JDBC datasource class which Java-Beans properties you have to set (e.g. it’s <code>User</code> and <code>Password</code> for Postgres, but it may be <code>UserName</code> and <code>Passphrase</code> for some other driver).</p>
<p>For Wildfly and Postgres this looks like this:</p>
<pre><code>    &lt;xa-datasource jndi-name="java:/jdbc/postgres-xa" pool-name="postgres-xa"&gt;
      &lt;driver&gt;postgres-driver&lt;/driver&gt;
      &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
      &lt;xa-datasource-property name="Url"&gt;jdbc:postgresql://127.0.0.1:6632/postgres&lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="User"&gt;postgres-user&lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="Password"&gt;postgres-password&lt;/xa-datasource-property&gt;
    &lt;/xa-datasource&gt;
</code></pre>
<p>For IBM WAS you set the datasource’s <strong>custom properties</strong> (see below).</p>
<p>Now when your app calls <code>javax.sql.DataSource.getConnection()</code> on the <strong>datasource proxy</strong> this time the proxy will call <code>getConnection()</code> (instead of <code>getConnection(String, String)</code>) on the underlying <em>real</em> datasource. In this case the <em>real</em> datasource must, should and usually will use the Java-Beans property values for <code>User</code> and <code>Password</code> (or whatever property it uses) to authenticate against the database. Note though that JDBC drives may support even more ways to supply authentication credentials (like Postgres which can take these from the JDBC URL).</p>
<p>When using a <em>Buttle</em> datasource (to proxy the <em>real</em> datasource) all this is working just the same way. Only now the <em>Buttle</em> datasource (proxy) introduces an additional indirection/delegation step.</p>
<p>You configure authentication for the <em>Buttle</em> datasource just like you do it for the <em>real</em> datasource.</p>
<p>With the following configuration the container will call <code>getConnection(String, String)</code> on the <em>Buttle</em> datasource which in turn calls <code>getConnection(String, String)</code> on the <em>real</em> datasource:</p>
<pre><code>    &lt;xa-datasource jndi-name="java:/jdbc/buttle-xa" pool-name="buttle-xa"&gt;
      &lt;driver&gt;buttle-driver&lt;/driver&gt;
      &lt;xa-datasource-class&gt;buttle.jdbc.XADataSource&lt;/xa-datasource-class&gt;
      &lt;security&gt;
       &lt;user-name&gt;postgres-user&lt;/user-name&gt;
       &lt;password&gt;postgres-password&lt;/password&gt;
      &lt;/security&gt;
      &lt;xa-datasource-property name="DelegateSpec"&gt;
       {
        :delegate-class org.postgresql.xa.PGXADataSource
        :url "jdbc:postgresql://127.0.0.1:6632/postgres"
       }
      &lt;/xa-datasource-property&gt;
    &lt;/xa-datasource&gt;
</code></pre>
<p>The <em>Buttle</em> datasource classes support the map-typed Java-Bean property <code>DelegateSpec</code>. Keys (other than <code>:delegate-class</code>) are used to set the corresponding Java-Bean property of the <em>real</em> datasource (see below for more details). So in the following example we’re setting <code>Url</code>, <code>User</code> and <code>Password</code> Java-Beans property values.</p>
<pre><code>    &lt;xa-datasource jndi-name="java:/jdbc/buttle-xa" pool-name="buttle-xa"&gt;
      &lt;driver&gt;buttle-driver&lt;/driver&gt;
      &lt;xa-datasource-class&gt;buttle.jdbc.XADataSource&lt;/xa-datasource-class&gt;
      &lt;xa-datasource-property name="DelegateSpec"&gt;
        {
          :delegate-class org.postgresql.xa.PGXADataSource
          :url "jdbc:postgresql://127.0.0.1:6632/postgres"
          :user "postgres-user"
          :password "postgres-password"
        }
      &lt;/xa-datasource-property&gt;
    &lt;/xa-datasource&gt;
</code></pre>
<p>In this case the container will call <code>getConnection()</code> on the <em>Buttle</em> datasource which in turn calls <code>getConnection()</code> on the <em>real</em> datasource which again must/will use the Java-Beans property values that <em>Buttle</em> has set before.</p>
<p>So when configuring authentication for your datasource keep in mind that the whole story starts with a call from the JEE container and this call will be determined by how you configure the datasource that your app retrieves from JNDI. From there the rest follows as described above.</p>
<h4><a href="#xa-datasource" name="xa-datasource"></a>XA-datasource</h4>
<p>In Wildfly you define an <code>&lt;xa-datasource&gt;</code> like this (for Postgres):</p>
<pre><code>&lt;xa-datasource jndi-name="java:/jdbc/postgres-xa" pool-name="postgres-xa"&gt;
  &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
  &lt;driver&gt;postgres-driver&lt;/driver&gt;
  &lt;security&gt;
    &lt;user-name&gt;postgres-user&lt;/user-name&gt;
    &lt;password&gt;postgres-password&lt;/password&gt;
  &lt;/security&gt;
  &lt;xa-datasource-property name="Url"&gt;jdbc:postgresql://127.0.0.1:6632/postgres&lt;/xa-datasource-property&gt;
&lt;/xa-datasource&gt;
</code></pre>
<p>Note that <code>security</code> configuration is included here only for you to be able to test this datasource through the Wildfly admin console GUI in isolation. When proxying this datasource with <em>Buttle</em> these <code>security</code> settings will never be used (as explaied in <strong>A note on authentication</strong>).</p>
<p>You can retrieve this from JNDI like this (done via nREPL into running Wildfly; build UBERJAR with <code>lein with-profile +swank,+wildfly
uberjar</code> to include nrepl and Swank):</p>
<pre><code>user=&gt; (buttle.util/jndi-lookup "java:/jdbc/postgres-xa")
#object[org.jboss.as.connector.subsystems.datasources.WildFlyDataSource ,,,]
</code></pre>
<p>Note though that Wildfly does <strong>not</strong> give us a <code>javax.sql.XADataSource</code> but a <code>javax.sql.DataSource</code>:</p>
<pre><code>user=&gt; (-&gt;&gt; (buttle.util/jndi-lookup "java:/jdbc/postgres-xa") .getClass .getInterfaces (into []))
[javax.sql.DataSource java.io.Serializable]
</code></pre>
<p>Since there is no (easy) way to implement <code>javax.sql.XADataSource</code> based on a <code>javax.sql.DataSource</code> <em>Buttle</em> cannot proxy XA-datasources retrieved from JNDI for Wildfly.</p>
<p>Others got bitten by this [1, 2] and it probably won’t get fixed [3]. So <em>Buttle</em> only supports <strong>(a)</strong> wrapping <em>real</em> <code>javax.sql.XADataSource</code> implemenations retrieved from JNDI and <strong>(b)</strong> <strong>creating</strong> a JDBC driver’s XA-datasource directly.</p>
<p>[1] <a href="https://stackoverflow.com/questions/52710666/exception-while-looking-up-xadatasource-using-jndi">https://stackoverflow.com/questions/52710666/exception-while-looking-up-xadatasource-using-jndi</a><br />[2] <a href="https://groups.google.com/forum/#!msg/ironjacamar-users/rxM1WbINnWI/RIdvEYn_iw4J">https://groups.google.com/forum/#!msg/ironjacamar-users/rxM1WbINnWI/RIdvEYn_iw4J</a><br />[3] <a href="https://issues.jboss.org/browse/JBJCA-657">https://issues.jboss.org/browse/JBJCA-657</a> </p>
<p><strong>Creating a JDBC driver’s XA-datasource directly</strong></p>
<p>So for Wildfly you define a <em>Buttle</em> XA-datasource and specify the <em>real</em> XA-datasource by setting the <code>DelegateSpec</code> property to a Clojure map form (to be exact I should say ‘a form that evaluates to a map’; line-breaks are removed so DO NOT use <code>;</code> comments other than at the very end). This map must have <code>:delegate-class</code> giving the <em>real</em> XA-datasource’s class (note that it IS a class-literal!). Any other map key/value will be used to set the <em>real</em> XA-datasource’s Java-Bean properties. You have to supply the correct property type through the map. Overloaded setter-methods are not supported.</p>
<pre><code>&lt;xa-datasource jndi-name="java:/jdbc/buttle-xa" pool-name="buttle-xa"&gt;
  &lt;xa-datasource-class&gt;buttle.jdbc.XADataSource&lt;/xa-datasource-class&gt;
  &lt;driver&gt;buttle-driver&lt;/driver&gt;
  &lt;security&gt;
    &lt;user-name&gt;postgres-user&lt;/user-name&gt;
    &lt;password&gt;postgres-password&lt;/password&gt;
  &lt;/security&gt;
  &lt;xa-datasource-property name="DelegateSpec"&gt;
    {:delegate-class org.postgresql.xa.PGXADataSource
     :url "jdbc:postgresql://127.0.0.1:6632/postgres"}
  &lt;/xa-datasource-property&gt;
&lt;/xa-datasource&gt;
</code></pre>
<h3><a href="#ibm-websphere" name="ibm-websphere"></a>IBM Websphere</h3>
<p>IBM Websphere (WAS) supports datasources of type <code>javax.sql.XADataSource</code> and <code>javax.sql.ConnectionPoolDataSource</code> (tested with WAS 9.0.0.8 ND).</p>
<p>For XA-datasource WAS (like Wildfly; see above) does not put a <code>javax.sql.XADataSource</code> into JNDI so <em>Buttle</em> cannot proxy XA-datasources from JNDI for WAS.</p>
<p>For WAS you have the following options:</p>
<ul>
  <li>
  <p><strong>proxy a JNDI <code>javax.sql.ConnectionPoolDataSource</code></strong><br /> Define the <em>Buttle</em> datasource with  <code>buttle.jdbc.ConnectionPoolDataSource</code> and target the <em>real</em>  datasource by setting <code>delegateSpec</code> to its JNDI name.</p></li>
  <li>
  <p><strong>define a <code>javax.sql.ConnectionPoolDataSource</code></strong><br /> Define the <em>Buttle</em> datasource with  <code>buttle.jdbc.ConnectionPoolDataSource</code> and (create) target the  <em>real</em> CP-datasource by setting <code>delegateSpec</code> to the map with  <code>:delegate-class &lt;real-jdbc-driver-cp-ds-class&gt;</code> and the  CP-datasource’s Java-Beans property values.</p></li>
  <li>
  <p><strong>define a <code>javax.sql.XADataSource</code></strong><br /> Define the <em>Buttle</em> datasource with <code>buttle.jdbc.XADataSource</code> and  (create) target the <em>real</em> XA-datasource by setting <code>delegateSpec</code>  to the map with <code>:delegate-class &lt;real-jdbc-driver-xa-ds-class&gt;</code> and  the XA-datasource’s Java-Beans property values.</p></li>
</ul>
<p><strong>Define <em>Buttle</em> JDBC provider</strong></p>
<p>For all options you need to define the <em>Buttle</em> <strong>JDBC provider</strong> first. You can repeat the following steps to define more than one provider (e.g. to define one provider for XA-datasources and one for CP-datasources).</p>
<p>In the WAS admin console navigate to <strong>Resources/JDBC/JDBC providers</strong>, select <strong>scope</strong> (i.e. your Cell/Node/Server), hit <strong>New…</strong>.</p>
<p><strong>Step 1: Create new JDBC provider</strong></p>
<ul>
  <li>select <strong>Database type</strong>: <code>User-defined</code></li>
  <li>enter <strong>Implementation class name</strong>:  <code>buttle.jdbc.ConnectionPoolDataSource</code> or <code>buttle.jdbc.XADataSource</code>  (see above)</li>
  <li>enter <strong>Name</strong> (e.g. <code>Buttle CP-DS</code>) and <strong>Description</strong></li>
  <li>hit <strong>Next</strong></li>
</ul>
<p><strong>Step 2: Enter database class path information</strong></p>
<ul>
  <li>enter <strong>Class path</strong>: <code>&lt;path-to-buttle-driver.jar&gt;</code></li>
  <li>hit <strong>Next</strong></li>
</ul>
<p><strong>Step 3: Summary</strong></p>
<ul>
  <li>just hit <strong>Finish</strong></li>
</ul>
<p><strong>Define <em>Buttle</em> datasource</strong></p>
<p>Now you need to define one or more datasources. In the WAS admin console navigate to <strong>Resources/JDBC/Data sources</strong>, select <strong>scope</strong> (i.e. your Cell/Node/Server), hit <strong>New…</strong>.</p>
<p><strong>Step 1: Enter basic data source information</strong></p>
<ul>
  <li>enter <strong>Data source name</strong> (e.g. <code>buttle_cp_ds</code>) and <strong>JNDI name</strong>  (e.g. <code>jdbc/buttle_cp_ds</code>)</li>
  <li>hit <strong>Next</strong></li>
</ul>
<p><strong>Step 2: Select JDBC provider</strong></p>
<ul>
  <li>select <strong>Select an existing JDBC provider</strong>: e.g. <code>Buttle CP-DS</code> (see above)</li>
  <li>hit <strong>Next</strong></li>
</ul>
<p><strong>Step 3: Enter database specific properties for the data source</strong></p>
<ul>
  <li><strong>Data store helper class name</strong>: do not change default  <code>com.ibm.websphere.rsadapter.GenericDataStoreHelper</code></li>
  <li><strong>Use this data source in container managed persistence (CMP)</strong>: do  not change default <em>checked</em></li>
  <li>just hit <strong>Next</strong></li>
</ul>
<p><strong>Step 4: Setup security aliases</strong></p>
<ul>
  <li>set all selections in <strong>Select the authentication values for this  resource</strong> to <strong>(none)</strong>. In this case authentication must come from  <em>Buttle</em> datasource configuration which is described below (see also  section <strong>A note on authentication</strong> above).</li>
  <li>hit <strong>Next</strong></li>
</ul>
<p><strong>Step 5: Summary</strong></p>
<ul>
  <li>just hit <strong>Finish</strong></li>
</ul>
<p><strong>Configure <em>Buttle</em> datasource</strong></p>
<p>Before you can use/test the <em>Buttle</em> datasource you need to configure it. Navigate to <strong>Resources/JDBC/Data sources</strong>, select <strong>scope</strong> (i.e. your Cell/Node/Server) and click on the <em>Buttle</em> datasource you want to configure. Click on <strong>Additional Properties</strong>/__Custom properties__.</p>
<p>If you have not added <code>delegateSpec</code> yet hit <strong>New…</strong> to add a new entry. Otherwise click on <code>delegateSpec</code> entry in the table.</p>
<p>When adding a new entry enter <strong>Name</strong> <code>delegateSpec</code>.</p>
<p>Enter/change the entry <strong>Value</strong>.</p>
<p><strong>Example: Postgres</strong></p>
<pre><code>{:delegate-class org.postgresql.ds.PGConnectionPoolDataSource
 :databaseName "&lt;postgres-db-name&gt;"
 :password "&lt;postgres-password&gt;"
 :portNumber (int &lt;postgres-port-number&gt;)
 :serverName "&lt;postgres-hostname&gt;"
 :user "&lt;postgres-user&gt;"}
</code></pre>
<p>Then hit <strong>OK</strong>.</p>
<p><strong>Test <em>Buttle</em> datasource</strong></p>
<p>Finally we can test/use the <em>Buttle</em> datasource. Navigate to <strong>Resources/JDBC/datasources</strong>, select <strong>scope</strong> (e.g. your cell/node/server). Select (checkbox) the datasource. Hit <strong>Test connection</strong>. If you have just changed the datasource you may get an error stating that you have to <em>synchronize</em> the datasource settings first. Go ahead and click <strong>Synchronize</strong> and then repeat the test.</p>
<h3><a href="#clojure" name="clojure"></a>Clojure</h3>
<p>Here <em>Buttle</em> UBERJAR (includes Clojure) is used like you would use any other JDBC driver.</p>
<pre><code>C:&gt;java -cp buttle-0.1.0-SNAPSHOT-driver.jar;postgresql-9.4.1212.jar clojure.main -r
Clojure 1.8.0
user=&gt; (use 'buttle.driver-manager)
;;--&gt; nil
(-&gt; (get-connection "jdbc:buttle:{:user \"&lt;user&gt;\" :password \"&lt;password&gt;\" :target-url \"jdbc:postgresql://127.0.0.1:6632/postgres?\"}" nil nil)
    .createStatement
    (.executeQuery "select * from pg_catalog.pg_tables where schemaname = 'pg_catalog'")
    (resultset-seq))
</code></pre>
<p>In [1] you find an example on how to use <em>Buttle</em> as a lib.</p>
<p>[1] <a href="https://github.com/henrik42/use-buttle">https://github.com/henrik42/use-buttle</a></p>
<h3><a href="#java" name="java"></a>Java</h3>
<pre><code>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class ButtleTest {

    public static void processEvent(Object e) {
       System.out.println("event : " + e);
    }

    public static void main(String[] args) throws Exception {

       System.setProperty("buttle.user-file", "examples/buttle/examples/java_events.clj");

       String user = System.getProperty("buttle_user");
       String password = System.getProperty("buttle_password");

       String jdbcUrl = "jdbc:postgresql://127.0.0.1:6632/postgres";
       String buttleUrl = String.format("jdbc:buttle:{:user \"%s\" :password \"%s\" :target-url \"%s\"}", user,
          password, jdbcUrl);

       Connection conn = DriverManager.getConnection(buttleUrl, user, password);

       Statement stmt = conn.createStatement();
       ResultSet rs = stmt.executeQuery("select * from pg_catalog.pg_tables where schemaname = 'pg_catalog'");

       for (int cc = rs.getMetaData().getColumnCount(); rs.next();) {
         for (int i = 1; i &lt;= cc; i++) {
          System.out.print(i == 1 ? "" : ",");
          System.out.print(rs.getObject(i));
         }
         System.out.println();
       }
    }
}
</code></pre>
<p>Build to <code>target/</code> dir:</p>
<pre><code>C:\&gt;javac -d target java\ButtleTest.java
</code></pre>
<p>And run (adjust paths as needed):</p>
<pre><code>C:\&gt;java -cp buttle-driver.jar;postgresql-9.4.1212.jar;target -Dbuttle_user=&lt;user&gt; -Dbuttle_password=&lt;password&gt; ButtleTest
</code></pre>
<h2><a href="#tests" name="tests"></a>Tests</h2>
<p>You’ll need a Postgres at <code>127.0.0.1:6632</code> (but see <code>jdbc-url</code> in <code>test/buttle/core_test.clj</code>).</p>
<p><strong>Windows</strong></p>
<pre><code>&gt; set buttle_user=&lt;user&gt;
&gt; set buttle_password=&lt;password&gt;
&gt; lein test
</code></pre>
<p><strong>Linux</strong></p>
<pre><code>$ buttle_user=&lt;user&gt; buttle_password=&lt;password&gt; lein test
</code></pre>
<h2><a href="#building-releasing" name="building-releasing"></a>Building &amp; Releasing</h2>
<p>See also aliases in <code>project.clj</code>.</p>
<ul>
  <li>build lib-jar: <code>lein jar</code></li>
  <li>build UBERJAR (<code>buttle-driver.jar</code>): <code>lein uberjar</code></li>
  <li>deploy lib-jar and UBERJAR to Nexus running on local machine: <code>lein with-profile +local deploy-all</code></li>
  <li>release: <code>lein with-profile +clojars,+skip-test release</code></li>
</ul>
<h2><a href="#todos" name="todos"></a>TODOS</h2>
<ul>
  <li>
  <p>review uses of butte.proxy/make-proxy and buttle.util/with-tccl –  which classloader is picked? And why.</p></li>
  <li>
  <p>add optional loading of <code>buttle-user-file.clj</code> via classloader to  <code>driver</code>. With that you don’t even need to set the system property  <code>buttle.user-file</code> to load your own code. You just need a dir that  the classpath/classloader of your app points to.</p></li>
  <li>
  <p>add <code>:driver-class</code> option to <em>Buttle</em> JDBC-URL so that <em>Buttle</em>  directly instanciates and uses that driver to delegate to (and not  indirectly delegate to the driver by calling DriverManager/connect).</p></li>
  <li>
  <p>add <code>:datasource-jndi-name</code> option to <em>Buttle</em> JDBC-URL so that  <em>Buttle</em> fetches a <code>DataSource</code> (not a <code>Driver</code>) from JNDI and  delegates to that.</p></li>
</ul></div></div></div></body></html>