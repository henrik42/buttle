<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Buttle README</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Buttle</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>Buttle README</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buttle</span></div></div></li><li class="depth-2 branch"><a href="buttle.connection-pool-data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection-pool-data-source</span></div></a></li><li class="depth-2 branch"><a href="buttle.data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data-source</span></div></a></li><li class="depth-2 branch"><a href="buttle.driver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver</span></div></a></li><li class="depth-2 branch"><a href="buttle.driver-manager.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver-manager</span></div></a></li><li class="depth-2 branch"><a href="buttle.event.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>event</span></div></a></li><li class="depth-2 branch"><a href="buttle.proxy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proxy</span></div></a></li><li class="depth-2 branch"><a href="buttle.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="buttle.xa-data-source.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xa-data-source</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#buttle-readme" name="buttle-readme"></a>Buttle README</h1>
<h2><a href="#what-is-it-" name="what-is-it-"></a>What is it?</h2>
<p><em>Buttle</em> is a proxying JDBC driver with hooks.</p>
<p><strong>proxies</strong></p>
<p><em>Buttle</em> ships a <code>java.sql.Driver</code> which delegates <code>connect</code> calls to a backing (or <em>real</em>) driver (like <code>org.postgresql.Driver</code>). The <em>Buttle</em> driver wraps a <em>Buttle</em> proxy around the returned <code>java.sql.Connection</code>. The <em>Buttle</em> proxy then (recursivly) does the same to the wrapped instance – i.e. it wraps a <em>Buttle</em> proxy around the return value of delegated method calls.</p>
<p>The effect of this is that the application which is using the <em>Buttle</em> <code>java.sql.Driver</code> will ever only call JDBC API methods through a <em>Buttle</em> proxy (e.g. for <code>java.sql.Statement</code> and <code>java.sql.ResultSet</code>).</p>
<p><em>Buttle</em> proxies are only constructed for methods (i.e. their returned values) that have interface-typed declared return types.</p>
<p><strong>hooks</strong></p>
<p><em>Buttle</em> proxies delegate calls to the backing JDBC driver’s instances through <code>buttle.proxy/handle</code> multi method. Via <code>buttle.proxy/def-handle</code> users can <em>inject/hook</em> their own multi-method implemenations (per interface/method) into the delegation mechanism. See example in <code>examples/buttle/examples/open_tracing.clj</code> and <code>examples/buttle/examples/handle.clj</code>.</p>
<p><strong>events</strong></p>
<p><em>Buttle</em> proxies also create <em>events</em> for every method invocation and completion incl. when an <code>Exception</code> is thrown (see <code>buttle.proxy/handle-default</code>).</p>
<p>These events include info about</p>
<ul>
  <li>timestamp of the event</li>
  <li>duration (for completion/<code>Exception</code>)</li>
  <li>stacktrace (for exceptions)</li>
  <li>invoked class/method</li>
  <li>arguments</li>
  <li>returned value/<code>Exception</code></li>
</ul>
<p>Events (see <code>event.clj</code>) are communicated through a <code>core.async</code> channel/mult so that users can consume <code>buttle.event/event-mult</code> to receive the events. See usage example in <code>examples/buttle/examples/event_channel.clj</code>.</p>
<p><strong>referencs</strong></p>
<p>Similar things have been done before:</p>
<ul>
  <li><a href="https://www.javaspecialists.eu/archive/Issue136.html">https://www.javaspecialists.eu/archive/Issue136.html</a></li>
  <li><a href="https://jaxenter.de/jdbc-treiber-selbstgebaut-java-trickkiste-636">https://jaxenter.de/jdbc-treiber-selbstgebaut-java-trickkiste-636</a></li>
  <li><a href="http://jamonapi.sourceforge.net/jamon_sql.html">http://jamonapi.sourceforge.net/jamon_sql.html</a></li>
  <li><a href="https://github.com/arthurblake/log4jdbc">https://github.com/arthurblake/log4jdbc</a></li>
  <li><a href="https://p6spy.readthedocs.io/en/latest/index.html">https://p6spy.readthedocs.io/en/latest/index.html</a></li>
  <li><a href="http://sfleiter.github.io/blog/2013/12/08/jboss-datasource-proxy-with-log4jdbc-log4j2/">http://sfleiter.github.io/blog/2013/12/08/jboss-datasource-proxy-with-log4jdbc-log4j2/</a></li>
</ul>
<h2><a href="#what-to-use-it-for-" name="what-to-use-it-for-"></a>What to use it for?</h2>
<p>Use it for</p>
<ul>
  <li>
  <p>testing</p></li>
  <li>
  <p>troubleshooting</p></li>
  <li>
  <p>debugging</p></li>
  <li>
  <p>performance measurements</p></li>
  <li>
  <p>application monitoring</p></li>
</ul>
<p><strong>Note</strong>: I haven’t done any measurements on how much <em>Buttle</em> hurts the performance.</p>
<h2><a href="#how-to-extend-" name="how-to-extend-"></a>How to extend?</h2>
<p>There are two ways to <em>hook into Buttle</em>:</p>
<p><strong>events</strong>: receive events from <em>Buttle</em> through  <code>buttle.event/event-mult</code> like this:</p>
<pre><code>(let [ch (clojure.core.async/chan)]
  (clojure.core.async/tap buttle.event/event-mult ch)
  (clojure.core.async/go
   (loop []
     (when-let [e (clojure.core.async/&lt;! ch)]
       (println e) ;; do something with the event
       (recur)))))
</code></pre>
<p><strong>multi method</strong>: <em>inject</em> your own proxy for <em>target</em>  interfaces/methods. This acts like an AOP advice/proxy. Note that in  this case you have to take care to send events if you need that (see  <code>buttle.proxy/handle-default</code>).</p>
<p>So you can (re-) register the <code>buttle.proxy/handle :default</code>.</p>
<pre><code>(defmethod buttle.proxy/handle :default [the-method target-obj the-args]
  (do-some-thing-with-call the-method target-obj the-args))
</code></pre>
<p>And you can register multi method implementation for just specific interfaces, methods or a combination of these (see <code>test/buttle/proxy_test.clj</code>, <code>examples/buttle/examples/open_tracing.clj</code> and <code>examples/buttle/examples/handle.clj</code> for more examples):</p>
<pre><code>(buttle.proxy/def-handle [java.sql.Connection :buttle/getCatalog] [the-method target-obj the-args]
  (do-some-thing-with-call the-method target-obj the-args))
</code></pre>
<p><code>do-some-thing-with-call</code> could look like this:</p>
<pre><code>(defn invoke-with-logging [the-method target-obj the-args]
  (println (format "buttle.examples.handle: INVOKE %s"
                   (pr-str [the-method target-obj (into [] the-args)])))
  (let [r (try
            (proxy/handle-default the-method target-obj the-args)
            (catch Throwable t
              (do
                (println (format "buttle.examples.handle: THROW %s : %s"
                                 (pr-str [the-method target-obj (into [] the-args)]) (pr-str t)))
                (throw t))))]
    (println (format "buttle.examples.handle: RETURN %s --&gt; %s"
                     (pr-str [the-method target-obj (into [] the-args)]) (pr-str r)))
    r))
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<h3><a href="#squirrel" name="squirrel"></a>SQuirreL</h3>
<p><strong>(1)</strong> In <code>squirrel-sql.bat</code> add system property <code>buttle.user-file</code> to java call:</p>
<pre><code>set BUTTLE="-Dbuttle.user-file=&lt;path-to&gt;/buttle/examples/handle.clj"
java [...] %BUTTLE% [...]
</code></pre>
<p><strong>(2)</strong> In the GUI add a <em>Driver</em> with <em>extra classpath</em>  <code>&lt;path-to&gt;/buttle-standalone.jar</code> and class <code>buttle.jdbc.Driver</code>.</p>
<p><strong>(3)</strong> In the GUI add an <em>Alias</em> with URL (replace <code>&lt;user&gt;</code> and <code>&lt;password&gt;</code>). Text  following <code>jdbc:buttle:</code> will be read as Clojure map form.</p>
<pre><code>jdbc:buttle:{:user "&lt;user&gt;" :password "&lt;password&gt;" :target-url "jdbc:postgresql://127.0.0.1:6632/postgres"}
</code></pre>
<h3><a href="#wildfly" name="wildfly"></a>Wildfly</h3>
<p>When using <em>Buttle</em> in Wildfly (either <em>domain</em> mode oder <em>standalone</em>) you can either include it in your application (but usually JDBC drivers are not included in the main app) or you can deploy it as a <em>module</em> (tested with Wildfly 12.0.0.Final).</p>
<p>For this you have to:</p>
<ul>
  <li>define a <code>&lt;module&gt;</code></li>
  <li>define a <code>&lt;driver&gt;</code></li>
  <li>define a <code>&lt;datasource&gt;</code> (or <code>&lt;xa-datasource&gt;</code>; see below)</li>
</ul>
<p><strong>(1)</strong> Define <code>&lt;module&gt;</code>: put this into  <code>&lt;wildfly-root&gt;/modules/buttle/main/module.xml</code>. You may have to  adjust <code>path</code> to <em>Buttle</em>’s JAR filename. Note that you have to  include <code>&lt;dependencies&gt;</code> for the <code>javax.api</code> base module and the  JDBC driver you want to wrap (Postgres in this case). Otherwise  <em>Buttle</em> won’t be able to <em>see</em> the JDBC driver’s classes.</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;module xmlns="urn:jboss:module:1.1" name="buttle"&gt;

  &lt;resources&gt;
    &lt;resource-root path="buttle-standalone.jar"/&gt;
  &lt;/resources&gt;

  &lt;dependencies&gt;
    &lt;module name="postgres"/&gt;
    &lt;module name="javax.api"/&gt; 
  &lt;/dependencies&gt;

&lt;/module&gt; 
</code></pre>
<p><strong>(2)</strong> Define <code>&lt;driver&gt;</code>: Note that Wildfly does not need to know  <em>Buttle</em>’s driver class (<code>buttle.jdbc.Driver</code>). It relies on  <em>Buttle</em> being loaded via SPI  (<code>META-INF/services/java.sql.Driver</code>). Wildfly then finds the  <em>Buttle</em> driver via <code>DriverManager/getConnection</code>.</p>
<pre><code>&lt;drivers&gt;
  &lt;driver name="buttle-driver" module="buttle"/&gt;
&lt;/drivers&gt;
</code></pre>
<p><strong>(3)</strong> Define <code>&lt;datasource&gt;</code>: in this example there is no extra  Postgres <code>&lt;datasource&gt;</code>/<code>&lt;driver&gt;</code> entry so Wildfly will not load  the Postgres JDBC driver for us. Therefore we put <code>:class-for-name
  "org.postgresql.Driver"</code> into the <em>Buttle</em> URL. Now <em>Buttle</em> loads  the JDBC driver’s class and usually these will register themselves  with the <code>DriverManager</code>. After that <em>Buttle</em> can connect to  Postgres through the <code>DriverManager</code>.</p>
<pre><code>&lt;datasource jndi-name="java:/jdbc/buttle-ds" pool-name="buttle-ds" use-java-context="true"&gt;
    &lt;driver&gt;buttle-driver&lt;/driver&gt;
    &lt;connection-url&gt;
        jdbc:buttle:{
            :user "&lt;user&gt;"
            :password "&lt;password&gt;"
            :class-for-name "org.postgresql.Driver"
            :target-url "jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;db-id&gt;"}
    &lt;/connection-url&gt;
&lt;/datasource&gt;
</code></pre>
<p>Instead of loading the class explicitly you can just use a class literal with some arbitrary key in the map – like this:</p>
<pre><code>    &lt;connection-url&gt;
        jdbc:buttle:{
            :user "&lt;user&gt;"
            :password "&lt;password&gt;"
            :_ org.postgresql.Driver
            :target-url "jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;db-id&gt;"}
    &lt;/connection-url&gt;
</code></pre>
<p>If you rather have Wildfly load the Postgres driver you just add a <code>&lt;driver&gt;</code> entry for Postgres. In this case you do not need the <code>:class-for-name</code>/class-literal entry.</p>
<pre><code>&lt;drivers&gt;
  &lt;driver name="buttle-driver" module="buttle"/&gt;
  &lt;driver name="postgresql" module="postgres"/&gt;
&lt;/drivers&gt;
</code></pre>
<p>There is yet another way to make Wildfly load Postgres JDBC driver. Instead of adding the <code>&lt;driver&gt;</code> you can add <code>services="import"</code> to the <code>module/dependencies</code>:</p>
<pre><code>&lt;module name="postgres" services="import"/&gt;
</code></pre>
<p>Since <em>Buttle</em> itself doesn’t give you much functionality you probably want to define <code>buttle.user-file</code> system property to have <em>Buttle</em> load your <em>hook code</em>:</p>
<pre><code>&lt;system-properties&gt;
  &lt;property name="buttle.user-file" value="&lt;path-to&gt;/buttle-user-file.clj" boot-time="true"/&gt;
&lt;/system-properties&gt;
</code></pre>
<h4><a href="#a-word-on-authentication" name="a-word-on-authentication"></a>A word on authentication</h4>
<p>Note that there are three (or four) places involved when it comes to authentication regarding the <em>Buttle</em> datasource and the proxied <em>real</em> datasource (in Wildfly and IBM Webpshere - see below):</p>
<p><strong>TBD</strong></p>
<ul>
  <li>
  <p><strong>the <em>real</em> datasource configuration</strong></p></li>
  <li>
  <p><strong>the <em>real</em> datasource’s authentication settings</strong></p></li>
  <li>
  <p><strong>the <em>Buttle</em> datasource configuration</strong></p></li>
</ul>
<h4><a href="#xa-datasource" name="xa-datasource"></a>XA-datasource</h4>
<p>You define an <code>&lt;xa-datasource&gt;</code> like this (for Postgres):</p>
<pre><code>&lt;xa-datasource jndi-name="java:/jdbc/postgres-xa" pool-name="postgres-xa"&gt;
  &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
  &lt;driver&gt;postgres-driver&lt;/driver&gt;
  &lt;security&gt;
    &lt;user-name&gt;postgres-user&lt;/user-name&gt;
    &lt;password&gt;postgres-password&lt;/password&gt;
  &lt;/security&gt;
  &lt;xa-datasource-property name="Url"&gt;jdbc:postgresql://127.0.0.1:6632/postgres&lt;/xa-datasource-property&gt;
&lt;/xa-datasource&gt;
</code></pre>
<p>You can retrieve this from JNDI like this (done via nREPL into running Wildfly; build UBERJAR with <code>lein with-profile +swank,+wildfly
uberjar</code> to include nrepl and Swank):</p>
<pre><code>user=&gt; (buttle.util/jndi-lookup "java:/jdbc/postgres-xa")
#object[org.jboss.as.connector.subsystems.datasources.WildFlyDataSource ,,,]
</code></pre>
<p>Note though that Wildfly does <strong>not</strong> give us a <code>javax.sql.XADataSource</code> but a <code>javax.sql.DataSource</code>:</p>
<pre><code>user=&gt; (-&gt;&gt; (buttle.util/jndi-lookup "java:/jdbc/postgres-xa") .getClass .getInterfaces (into []))
[javax.sql.DataSource java.io.Serializable]
</code></pre>
<p>Since there is no (easy) way to implement <code>javax.sql.XADataSource</code> based on a <code>javax.sql.DataSource</code> <em>Buttle</em> cannot proxy XA-datasources retrieved from JNDI for Wildfly.</p>
<p>Others got bitten by this [1, 2] and it probably won’t get fixed [3]. So <em>Buttle</em> only supports <strong>(a)</strong> wrapping <em>real</em> <code>javax.sql.XADataSource</code> implemenations retrieved from JNDI and <strong>(b)</strong> <strong>creating</strong> a JDBC driver’s XA-datasource directly.</p>
<p>[1] <a href="https://stackoverflow.com/questions/52710666/exception-while-looking-up-xadatasource-using-jndi">https://stackoverflow.com/questions/52710666/exception-while-looking-up-xadatasource-using-jndi</a><br />[2] <a href="https://groups.google.com/forum/#!msg/ironjacamar-users/rxM1WbINnWI/RIdvEYn_iw4J">https://groups.google.com/forum/#!msg/ironjacamar-users/rxM1WbINnWI/RIdvEYn_iw4J</a><br />[3] <a href="https://issues.jboss.org/browse/JBJCA-657">https://issues.jboss.org/browse/JBJCA-657</a> </p>
<p><strong>Creating a JDBC driver’s XA-datasource directly</strong></p>
<p>So for Wildfly you define a <em>Buttle</em> XA-datasource and specify the <em>real</em> XA-datasource by setting the <code>DelegateSpec</code> property to a Clojure map form (to be exact I should say ‘a form that evaluates to a map’; line-breaks are removed so DO NOT use <code>;</code> comments other than at the very end). This map must have <code>:delegate-class</code> giving the <em>real</em> XA-datasource’s class (note that it IS a class-literal!). Any other map key/value will be used to set the <em>real</em> XA-datasource’s Java-Bean properties. You have to supply the correct property type through the map. Overloaded setter-methods are not supported.</p>
<pre><code>&lt;xa-datasource jndi-name="java:/jdbc/buttle-xa" pool-name="buttle-xa"&gt;
  &lt;xa-datasource-class&gt;buttle.jdbc.XADataSource&lt;/xa-datasource-class&gt;
  &lt;driver&gt;buttle-driver&lt;/driver&gt;
  &lt;security&gt;
    &lt;user-name&gt;postgres-user&lt;/user-name&gt;
    &lt;password&gt;postgres-password&lt;/password&gt;
  &lt;/security&gt;
  &lt;xa-datasource-property name="DelegateSpec"&gt;
    {:delegate-class org.postgresql.xa.PGXADataSource
     :url "jdbc:postgresql://127.0.0.1:6632/postgres"}
  &lt;/xa-datasource-property&gt;
&lt;/xa-datasource&gt;
</code></pre>
<h3><a href="#ibm-websphere" name="ibm-websphere"></a>IBM Websphere</h3>
<p>IBM Websphere (WAS) supports datasources of type <code>javax.sql.XADataSource</code> and <code>javax.sql.ConnectionPoolDataSource</code> (tested with WAS 9.0.0.8 ND).</p>
<p>For XA-datasource WAS (like Wildfly; see above) does not put a <code>javax.sql.XADataSource</code> into JNDI so <em>Buttle</em> cannot proxy XA-datasources from JNDI for WAS.</p>
<p>For WAS you have the following options:</p>
<ul>
  <li>
  <p><strong>proxy a JNDI <code>javax.sql.ConnectionPoolDataSource</code></strong><br /> Define the <em>Buttle</em> datasource with  <code>buttle.jdbc.ConnectionPoolDataSource</code> and target the <em>real</em>  datasource by setting <code>delegateSpec</code> to its JNDI name.</p></li>
  <li>
  <p><strong>define a <code>javax.sql.ConnectionPoolDataSource</code></strong><br /> Define the <em>Buttle</em> datasource with  <code>buttle.jdbc.ConnectionPoolDataSource</code> and (create) target the  <em>real</em> CP-datasource by setting <code>delegateSpec</code> to the map with  <code>:delegate-class &lt;real-jdbc-driver-cp-ds-class&gt;</code> and the  CP-datasource’s Java-Beans property values.</p></li>
  <li>
  <p><strong>define a <code>javax.sql.XADataSource</code></strong><br /> Define the <em>Buttle</em> datasource with <code>buttle.jdbc.XADataSource</code> and  (create) target the <em>real</em> XA-datasource by setting <code>delegateSpec</code>  to the map with <code>:delegate-class &lt;real-jdbc-driver-xa-ds-class&gt;</code> and  the XA-datasource’s Java-Beans property values.</p></li>
</ul>
<p><strong>Define <em>Buttle</em> JDBC provider</strong></p>
<p>For all options you need to define the <em>Buttle</em> <strong>JDBC provider</strong> first. You can repeat the following steps to define more than one provider (e.g. to define one provider for XA-datasources and one for CP-datasources).</p>
<p>In the WAS Admin Console navigate to <strong>Resources/JDBC/JDBC provider</strong>, select <strong>scope</strong> (e.g. your cell/node/server), hit <strong>new</strong>.</p>
<p><strong>Step 1:</strong></p>
<ul>
  <li>select <strong>database type</strong>: <code>user defined</code></li>
  <li>enter <strong>implementation class</strong>: <code>buttle.jdbc.ConnectionPoolDataSource</code> or  <code>buttle.jdbc.XADataSource</code> (see above)</li>
  <li>enter <strong>name</strong> (e.g. <code>Buttle CP-DS</code>) and <strong>description</strong></li>
  <li>hit <strong>next</strong></li>
</ul>
<p><strong>Step 2:</strong></p>
<ul>
  <li>enter <strong>classpath</strong>: <code>&lt;path-to-buttle-standalone.jar&gt;</code></li>
  <li>hit <strong>next</strong></li>
</ul>
<p><strong>Step 3:</strong></p>
<ul>
  <li>just hit <strong>done</strong></li>
</ul>
<p><strong>Define <em>Buttle</em> datasource</strong></p>
<p>Now you define one or more datasources. In the WAS Admin Console navigate to <strong>Resources/JDBC/datasources</strong>, select <strong>scope</strong> (e.g. your cell/node/server), hit <strong>new</strong>.</p>
<p><strong>Step 1:</strong></p>
<ul>
  <li>enter <strong>name</strong> (e.g. <code>buttle_cp_ds</code>) and <strong>JNDI name</strong>  (e.g. <code>jdbc/buttle_cp_ds</code>)</li>
  <li>hit <strong>next</strong></li>
</ul>
<p><strong>Step 2:</strong></p>
<ul>
  <li>select <strong>JDBC provider</strong>: e.g. <code>Buttle CP-DS</code> (see above)</li>
  <li>hit <strong>next</strong></li>
</ul>
<p><strong>Step 3:</strong></p>
<ul>
  <li><strong>helper</strong>: do not change default <code>com.ibm.websphere.rsadapter.GenericDataStoreHelper</code></li>
  <li>just hit <strong>next</strong></li>
</ul>
<p><strong>Step 4:</strong></p>
<ul>
  <li>leave all authentication selections <strong>empty</strong>. In this case  authentication must come from <em>Buttle</em> datasource.</li>
  <li>just hit <strong>next</strong></li>
</ul>
<p><strong>Step 5:</strong></p>
<ul>
  <li>just hit <strong>next</strong></li>
</ul>
<p><strong>Configure <em>Buttle</em> datasource</strong></p>
<p>Before you can use/test the <em>Buttle</em> datasource you need to configure it. Navigate to <strong>Resources/JDBC/datasources</strong>, select <strong>scope</strong> (e.g. your cell/node/server) and click on the <em>Buttle</em> datasource you want to configure.</p>
<p>Click on <strong>adjust properties</strong>. If you have not added <code>delegateSpec</code> hit <strong>add</strong>. Otherwise click on <code>delegateSpec</code> entry in the table.</p>
<p>Enter/change <strong>value</strong>.</p>
<p><strong>Example: Postgres</strong></p>
<pre><code>{:delegate-class org.postgresql.ds.PGConnectionPoolDataSource
 :databaseName "&lt;postgres-db-name&gt;"
 :password "&lt;postgres-password&gt;"
 :portNumber (int &lt;postgres-port-number&gt;)
 :serverName "&lt;postgres-hostname&gt;"
 :user "&lt;postgres-user&gt;"}
</code></pre>
<p>Then hit <strong>ok</strong>.</p>
<p><strong>Test <em>Buttle</em> datasource</strong></p>
<p>Finally we can test/use the <em>Buttle</em> datasource. Navigate to <strong>Resources/JDBC/datasources</strong>, select <strong>scope</strong> (e.g. your cell/node/server). Select (checkbox) the datasource. Hit <strong>test connection</strong>. If you have just changed the datasource you may get an error stating that you have to <em>synchronize</em> the datasource settings first. Go ahead and click <strong>synchronize</strong> and then repeat the test.</p>
<h3><a href="#clojure" name="clojure"></a>Clojure</h3>
<pre><code>C:&gt;java -cp buttle-0.1.0-SNAPSHOT-standalone.jar;postgresql-9.4.1212.jar clojure.main -r
Clojure 1.8.0
user=&gt; (use 'buttle.driver-manager)
;;--&gt; nil
(-&gt; (get-connection "jdbc:buttle:{:user \"&lt;user&gt;\" :password \"&lt;password&gt;\" :target-url \"jdbc:postgresql://127.0.0.1:6632/postgres?\"}" nil nil)
    .createStatement
    (.executeQuery "select * from pg_catalog.pg_tables where schemaname = 'pg_catalog'")
    (resultset-seq))
</code></pre>
<h3><a href="#java" name="java"></a>Java</h3>
<pre><code>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class ButtleTest {

    public static void processEvent(Object e) {
       System.out.println("event : " + e);
    }

    public static void main(String[] args) throws Exception {

       System.setProperty("buttle.user-file", "examples/buttle/examples/java_events.clj");

       String user = System.getProperty("buttle_user");
       String password = System.getProperty("buttle_password");

       String jdbcUrl = "jdbc:postgresql://127.0.0.1:6632/postgres";
       String buttleUrl = String.format("jdbc:buttle:{:user \"%s\" :password \"%s\" :target-url \"%s\"}", user,
          password, jdbcUrl);

       Connection conn = DriverManager.getConnection(buttleUrl, user, password);

       Statement stmt = conn.createStatement();
       ResultSet rs = stmt.executeQuery("select * from pg_catalog.pg_tables where schemaname = 'pg_catalog'");

       for (int cc = rs.getMetaData().getColumnCount(); rs.next();) {
         for (int i = 1; i &lt;= cc; i++) {
          System.out.print(i == 1 ? "" : ",");
          System.out.print(rs.getObject(i));
         }
         System.out.println();
       }
    }
}
</code></pre>
<p>Build to <code>target/</code> dir:</p>
<pre><code>C:\&gt;javac -d target java\ButtleTest.java
</code></pre>
<p>And run (adjust paths as needed):</p>
<pre><code>C:\&gt;java -cp buttle-standalone.jar;postgresql-9.4.1212.jar;target -Dbuttle_user=&lt;user&gt; -Dbuttle_password=&lt;password&gt; ButtleTest
</code></pre>
<h2><a href="#tests" name="tests"></a>Tests</h2>
<p>You’ll need a Postgres at <code>127.0.0.1:6632</code> (but see <code>jdbc-url</code> in <code>test/buttle/core_test.clj</code>).</p>
<p><strong>Windows</strong></p>
<pre><code>&gt; set buttle_user=&lt;user&gt;
&gt; set buttle_password=&lt;password&gt;
&gt; lein test
</code></pre>
<p><strong>Linux</strong></p>
<pre><code>$ buttle_user=&lt;user&gt; buttle_password=&lt;password&gt; lein test
</code></pre>
<h2><a href="#building" name="building"></a>Building</h2>
<p>Use <code>lein make-doc</code> to build documenation to <code>resources/public/generated-doc</code>.</p>
<p>Use <code>lein uberjar</code> to build the minimum <em>Buttle</em> UBERJAR. It’ll contain <em>Buttle</em>, Clojure and <code>core.async</code>. It won’t contain the Open Tracing API and no Jaeger.</p>
<p>Use <code>lein with-profile +jaeger,+wildfly uberjar</code> to build an UBERJAR incl. Open Tracing and Jaeger and suitable for usage in Wildfly.</p>
<p>You can use <em>Buttle</em> as a library (<code>buttle.proxy</code> could probably be used for proxying other APIs like LDAP und JMS) but I usually use it like you would use a self-contained JDBC driver. If you have problems using <em>Buttle</em> in Clojure environments then you may have to fix the <code>make-</code> aliases.</p>
<h2><a href="#todos" name="todos"></a>TODOS</h2>
<ul>
  <li>
  <p>review uses of butte.proxy/make-proxy and buttle.util/with-tccl –  which classloader is picked? And why.</p></li>
  <li>
  <p>add optional loading of <code>buttle-user-file.clj</code> via classloader to  <code>driver</code>. With that you don’t even need to set the system property  <code>buttle.user-file</code> to load your own code. You just need a dir that  the classpath/classloader of your app points to.</p></li>
  <li>
  <p>add <code>:driver-class</code> option to <em>Buttle</em> JDBC-URL so that <em>Buttle</em>  directly instanciates and uses that driver to delegate to (and not  indirectly delegate to the driver by calling DriverManager/connect).</p></li>
  <li>
  <p>add <code>:datasource-jndi-name</code> option to <em>Buttle</em> JDBC-URL so that  <em>Buttle</em> fetches a <code>DataSource</code> (not a <code>Driver</code>) from JNDI and  delegates to that.</p></li>
</ul></div></div></div></body></html>