<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>(German) Einführung in Buttle</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Buttle</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="README.html"><div class="inner"><span>Buttle README</span></div></a></li><li class="depth-1  current"><a href="intro_de.html"><div class="inner"><span>(German) Einführung in Buttle</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buttle</span></div></div></li><li class="depth-2 branch"><a href="buttle.driver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver</span></div></a></li><li class="depth-2 branch"><a href="buttle.driver-manager.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>driver-manager</span></div></a></li><li class="depth-2 branch"><a href="buttle.event.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>event</span></div></a></li><li class="depth-2 branch"><a href="buttle.proxy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proxy</span></div></a></li><li class="depth-2"><a href="buttle.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#german-einführung-in-buttle" name="german-einführung-in-buttle"></a>(German) Einführung in Buttle</h1>
<p><strong>Hinweis:</strong> Die folgende Doku beschreibt den Zielzustand für <em>Buttle</em>. Ich habe erst einen Teil der beschriebenen Funktionalität umgesetzt.</p>
<p><em>Buttle</em> ist ein JDBC-Treiber [1, 2]. <em>Buttle</em> selbst stellt jedoch keine Verbindung zu einer Datenbank her. Stattdessen fungiert <em>Buttle</em> als <strong>Proxy</strong> (oder <em>Wrapper</em>) zu einem <em>echten</em> JDBC-Treiber.</p>
<p><em>Buttle</em> stellt die Klasse <code>buttle.jdbc.Driver</code>. Die Klasse implementiert das Interface <code>java.sql.Driver</code> [3] und kann als <code>Driver</code> am <code>java.sql.DriverManager</code> <em>registriert</em> werden. Damit kann <em>Buttle</em> wie jeder andere JDBC-Treiber in einer Anwendung verwendet werden.</p>
<p><em>Buttle</em> benötigt natürlich einen <em>echten</em> JDBC-Treiber, an den er die eingehenden Methodenaufrufe <em>deligieren</em> kann, damit auch tatsächlich ein Datenbankzugriff erfolgt (_Buttle_ ist <strong>kein</strong> <em>Mock</em>; könnte man aber auch mal drüber nachdenken…). Es gibt verschiedene Möglichkeiten, wie man die Beziehung von <em>Buttle</em> (als Proxy) zu einem <em>echten</em> JDBC-Treiber herstellt (vgl. unten).</p>
<p>Sobald <em>Buttle</em> als Proxy eingerichtet ist, führt er zu folgenden Effekten:</p>
<ul>
  <li>
  <p>Die <code>java.sql.Connection</code> des <em>echten</em> JDBC-Treibers (die man durch  <code>java.sql.Driver/connect</code> oder  <code>java.sql.DriverManager/getConnection</code> erhält) wird mit einem  <em>Buttle</em> <code>Connection</code>-Proxy versehen und der Proxy wird als  Rückgabewert geliefert.</p></li>
  <li>
  <p>Dieser <em>Buttle</em> <code>Connection</code>-Proxy liefert für alle überladenen  <code>java.sql.Connection/createStatement</code> Methoden einen <em>Buttle</em>  <code>Statement</code>-Proxy zu dem <code>java.sql.Statement</code> des <em>echten</em>  JDBC-Treibers.</p></li>
  <li>
  <p>Der <code>Statement</code>-Proxy liefert für alle Methoden, die ein  <code>java.sql.ResultSet</code> liefern, auch wiederum einen <em>Buttle</em>  <code>ResultSet</code>-Proxy um das <code>ResultSet</code> des <em>echten</em> JDBC-Treibers.</p></li>
</ul>
<p>Die verschiedenen <em>Buttle</em> Proxys haben (neben der Delegation an das gewrappte Objekt) folgende Funktionen:</p>
<ul>
  <li>
  <p><strong>Events:</strong> beim Eintritt und beim Austritt (auch im  <code>Exception</code>-Fall) der Methoden werden <em>Events</em> erzeugt. Diese werden  in einen <em>Kanal</em> (<code>core.async</code> channel) geschrieben. Man kann sich  von außen an diesen Kanal <em>binden</em> (wie ein <em>Observer</em>), so dass man  die <em>Events</em> konsumieren kann. Damit kann man z.B. <strong>Monitoring</strong>  und <strong>Performanzmessungen</strong> unterstützen.</p></li>
  <li>
  <p><strong>Logging:</strong> es gibt einen in <em>Buttle</em> schon eingebauten Konsumenten  für <em>Events</em>, der die <em>Events</em> in ein Log ausgibt.</p></li>
</ul>
<p>Bisher unterstützen die Proxys keinen weiteren Delegationsmechanismus. Es ist also nicht möglich, den Proxys einen <em>Hander</em> o.ä. zu übergeben, an den sie die Ausführung der Proxy-Logik delegieren würden. Mit so einem Feature wäre es z.B. möglich, in solchen Handlern <strong>Mock-Funktionalitäten</strong> zu realisieren.</p>
<p>[1] <a href="https://docs.oracle.com/javase/tutorial/jdbc/">https://docs.oracle.com/javase/tutorial/jdbc/</a><br />[2] <a href="https://www.tutorialspoint.com/jdbc/">https://www.tutorialspoint.com/jdbc/</a><br />[3] <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Driver.html">https://docs.oracle.com/javase/8/docs/api/java/sql/Driver.html</a> </p>
<h1><a href="#buttle-als-proxy-zu-einem-echten-jdbc-treiber-einrichten" name="buttle-als-proxy-zu-einem-echten-jdbc-treiber-einrichten"></a>Buttle als Proxy zu einem echten JDBC-Treiber einrichten</h1>
<p>Da <em>Buttle</em> nur ein Proxy um einen <em>echten</em> JDBC-Treiber ist, kann er sich an bestimmte Stellen <strong>nicht</strong> in die Beziehungen zwischen den verschiedenen Objekten einklinken, die der <em>echte</em> JDBC-Treiber liefert/kontrolliert.</p>
<p>So gibt es z.B. eine Beziehung zwischen einem <code>java.sql.Statement</code> und den <code>java.sql.ResultSet</code> Ojekten, die durch das <code>Statement</code> erzeugt wurden (z.B. weil ein JDBC-Treiber <em>seine</em> <code>ResutSet</code>s schließen muss, wenn das <code>Statement</code> geschlossen wird, das sie erzeugt hat. Und dazu muss das <code>Statement</code> wissen, welche offenen <code>ResultSet</code>s es in dem Augenblick gibt). Dabei wird keiner der <em>Buttle</em> Proxys einbezogen. Die <em>Buttle</em> Proxys befinden sich also nur <em>zwischen</em> dem <strong>Anwendungscode</strong> und dem <em>echte</em> JDBC-Treiber. Somit können von <em>Buttle</em> auch nur Aufrufe <em>abgefangen</em> werden, die von der Anwendung in die JDBC-API gehen.</p>
<p>Soweit ich weiß, unterstützt die JDBC-API kein <em>Factory-Pattern</em>, mit dem es möglich wäre, direkt in die Erzeugung der verschiedenen Instanzen (<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>) einzugreifen. Damit wäre es dann möglich, die Proxys auch <em>zwischen</em> den verschiedenen Instanzen zu <em>installieren</em> (so wie es z.B. Spring macht).</p>
<h2><a href="#und" name="und"></a><code>java.sql.DriverManager</code> und <code>java.sql.Driver</code></h2>
<p>I.d.R. wird von Anwendungen die Methode <code>java.sql.DriverManager/getConnection</code> verwendet, um eine Verbindung zu einer Datenbank aufzubauen.</p>
<p>Intern verwendet der <code>DriverManager</code> dazu eine Menge von <strong>registrierten</strong> <code>java.sql.Driver</code> (vgl. unten). Jeder JDBC-Treiber (z.B. für Postgres, DB2, Oracle) liefert eine Klasse, die dieses <code>Interface</code> implementiert. <em>Buttle</em> liefert ebenfalls eine solche Klasse (<code>buttle.jdbc.Driver</code>).</p>
<p><strong>Hinweis</strong>: es ist <strong>nicht notwendig</strong> (d.h. die JDBC-API Spezifikation <strong>fordert es nicht</strong>), dass diese <code>Driver</code>-Klassen der JDBC-Treiber einen publiken/argumentlosen Konstruktor besitzen. Man kann also im allgemeinen <strong>nicht</strong> davon ausgehen, dass man selber diese Klassen instanziieren kann.</p>
<p>Es gibt drei Methoden, durch die die Registrierung des/der <code>Driver</code> erfolgt:</p>
<ul>
  <li>
    <p><strong>gesteuert durch die Anwendung</strong>: die Anwendung lädt aktiv/explizit  eine Klasse des gewünschten JDBC-Treibers. I.d.R. erfolgt dies via  <code>Class.forName</code>. D.h. in diesem Fall muss die Anwendung wissen, wie  der JDBC-Treiber geladen wird und sie muss die entsprechende  Ladelogik liefern.<br /> <strong>Hinweis:</strong> es muss sich bei dieser Klasse <strong>nicht zwingend</strong> um  jene Klasse handeln, die das Interface <code>java.sql.Driver</code>  implementiert (häufig ist das aber der Fall). Die einzige  Anforderung ist, dass die geladene Klasse  den/die <code>Driver</code> am <code>DriverManager</code> <strong>registriert</strong> (vgl. unten).<br /> <strong>Beispiel:</strong></p>
    <pre><code>Class.forName("org.postgresql.Driver")
</code></pre>
  </li>
  <li>
  <p><strong>gesteuert durch den</strong> <code>DriverManager</code>: sobald die Klasse  <code>java.sql.DriverManager</code> geladen wird (z.B. weil die Anwendung eine  Methode des <code>DriverManager</code> aufruft), wird während der statischen  Initialisierung via <code>java.util.ServiceLoader.load(Driver.class)</code>  versucht, <em>Service-Provider</em> für <code>java.sql.Driver</code> zu finden. Das  bedeutet, dass nach der Resource <code>META-INF/services/java.sql.Driver</code>  gesucht wird. Falls sie gefunden wird (und es kann mehrere Vorkommen  geben!), wird für jedes Vorkommen der Inhalt der Resource als  Klassennamen interpretiert und die genannte Klasse wird geladen.<br /> <strong>Hinweis:</strong> Im Falls des <em>Service-Providers</em> <strong>muss</strong> die  angegebene Klasse einen argumentlosen Konstruktor haben, da der  <em>Service-Loader</em> eine Instanz der Klasse erzeugt. Durch das  Laden/Instanziieren muss dann wiederum die Registrierung des  <code>Driver</code> am <code>DriverManager</code> erfolgen.</p></li>
  <li>
    <p><strong>gesteuert durch den</strong> <code>DriverManager</code>: ebenfalls während der  statischen Initialisierung, wertet der <code>DriverManager</code> die  System-Property <code>jdbc.drivers</code> aus. Der Wert muss (wenn er denn  überhaupt gesetzt ist) eine <code>:</code>-getrennte Liste von Klassennamen  sein. Der <code>DriverManager</code> iteriert über diese Liste und ruft für  jeden Klassennamen <code>&lt;class-name&gt;</code> die Methode  <code>Class.forName(&lt;class-name&gt;)</code> auf.<br /> <strong>Beispiel:</strong></p>
    <pre><code>-Djdbc.drivers='org.postgresql.Driver:oracle.jdbc.driver.OracleDriver'
</code></pre>
  </li>
</ul>
<p>Unabhängig davon, über welchen dieser Mechanismen der JDBC-Treiber geladen wird, ist es Aufgabe der geladenen Klasse, den/die <code>Driver</code> aktiv via <code>java.sql.DriverManager/registerDriver</code> beim <code>DriverManager</code> zu <strong>registrieren</strong>. D.h. das <strong>Laden der Klassen</strong> kann durch den <code>DriverManager</code> erfolgen, er übernimmt aber <strong>nicht</strong> selber aktiv/explizit das <strong>Registrieren</strong> des/der <code>Driver</code> (sondern er stößt es eben nur indirekt an).</p>
<p><strong>Wichtig:</strong> weder die Anwendung noch der <code>DriverManager</code> erzeugen selber Instanzen der <code>Driver</code> Klasse(n) des JDBC-Treibers. Auch <em>Buttle</em> kann nicht von sich aus Instanzen diese Klassen erzeugen. Instanzen werden nur intern im JDBC-Treiber erzeugt und dann an den <code>DriverManager</code> übergeben.</p>
<h2><a href="#buttle-jdbc-driver" name="buttle-jdbc-driver"></a>buttle.jdbc.Driver</h2>
<p>Der <em>Buttle</em> <code>Driver</code> kann wie jeder andere JDBC-Treiber geladen werden (vgl. oben). Es werden alle drei oben erläuterten Mechanismen unterstützt (d.h. der Treiber liefert auch eine passende <code>META-INF/services/java.sql.Driver</code>). Falls der <code>Driver</code> über die Anwendungslogik geladen werden soll und/oder über die System-Property <code>jdbc.drivers</code>, muss als zu ladene Klasse <code>buttle.jdbc.Driver</code> verwendet werden.</p>
<p><em>Buttle</em> hat keine direkte/explizite Kenntnis davon, für welche(n) <em>echten</em> JDBC-Treiber er als Proxy eingesetzt werden soll.</p>
<p>Es gibt die Möglichkeit, dass der <em>echte</em> Treiber über einen der drei obigen Mechanismen geladen wird. <em>Buttle</em> muss dann <strong>(a)</strong> dafür sorgen, dass der eigene <code>Driver</code> (anstatt des <em>echten</em>) für die JDBC-Zugriffe durch die Anwendung verwendet wird und <em>Buttle</em> muss <strong>(b)</strong> Zugriff auf den <em>echten</em> <code>Driver</code> bekommen, um durch die eigenen Proxys an ihn zu deligieren.</p>
<p>Als Ergänzung zu den drei oben beschriebenen Ladeoptionen kann der <em>echte</em> JDBC-Treiber auch über/durch <em>Buttle</em> geladen werden (vgl. unten). Dies entspricht dem ersten oben genannten Mechanismus, nur dass in diesem Fall die <em>Ladelogik</em> in <em>Buttle</em> implementiert ist und nicht in der Anwendung. <em>Buttle</em> verwendet in diesem Fall ebenfalls <code>Class.forName</code>. Ansonsten unterscheidet sich diese Option nicht von den anderen.</p>
<p>Unabhängig davon, wie das Laden des <em>echten</em> JDBC-Treibers <em>angestoßen</em> wird, muss unterschieden werden, ob die Anwendung eine JDBC-URL verwendet, die <strong>(A)</strong> vom <em>echten</em> JDBC-Treiber unterstützt wird (z.B. <code>jdbc:postgres:</code> für Postgres), oder ob <strong>(B)</strong> die Anwendung eine <em>Buttle</em>-URL verwendet (z.B. <code>jdbc:buttle:</code>).</p>
<h2><a href="#buttle-jdbc-driverreplacingdriver" name="buttle-jdbc-driverreplacingdriver"></a>buttle.jdbc.DriverReplacingDriver</h2>
<p>Im (einfacheren) Fall <strong>(B)</strong> sorgt der <code>DriverManager</code> selber für <strong>(a)</strong>, da kein anderer <code>Driver</code> die <em>Buttle</em>-URL unterstützen wird. Für diesen Fall muss aber eben die JDBC-URL <strong>in der Anwendung</strong> angepasst werden (das kann oder kann eben nicht gewünscht/möglich sein).</p>
<p>Im (kniffligeren) Fall <strong>(A)</strong> ist die <strong>Reihenfolge</strong> der (intern im <code>DriverManager</code>) <strong>registrierten</strong> <code>Driver</code> entscheidend: sollte <strong>erst</strong> der <em>Buttle</em> <code>Driver</code> vom <code>DriverManager</code> angesprochen werden (vgl. <code>java.sql.DriverManager.getConnection</code>), kann er auch zu einer <em>fremden/echten</em> JDBC-URL (wie <code>jdbc:postgres:</code>) eine (Proxy) <code>Connection</code> liefern. Dadurch wird er vom <code>DriverManager</code> für die betreffende JDBC-URL <em>ausgewählt</em> und kann anschließend einen <code>Connection</code> Proxy liefen. Wird jedoch erst der <em>echte</em> <code>Driver</code> (in diesem Fall z.B. der Postgres-Treiber) angesprochen, so kann der <em>Buttle</em> <code>Driver</code> nicht eingreifen.</p>
<p>Daher liefert <em>Buttle</em> die Klasse <code>buttle.jdbc.DriverReplacingDriver</code>, die den <em>Buttle</em> <code>Driver</code> registriert und alle (bis zu diesem <strong>Zeitpunkt</strong>) <strong>registrierten</strong> <code>Driver</code>, die <strong>vor</strong> dem <em>Buttle</em> <code>Driver</code> im <code>DriverManager</code> registriert sind, <strong>deregistriert</strong> und dann sofort wieder <strong>registriert</strong>. Dadurch werden diese <em>erneut-registrierten</em> <code>Driver</code> anschließend im <code>DriverManager</code> von der Reihenfolge her <em>hinter</em> dem <em>Buttle</em> Driver geführt. D.h. es wird die gewünschte Reihenfolge der <code>Driver</code> hergestellt, so dass <em>Buttle</em> wie gewünscht eingreifen kann.</p>
<p><strong>Hinweis:</strong> man könnte das nun folgend beschrieben Verfahren auch ohne <strong>erneute</strong> Registrierung der <code>Driver</code> am <code>DriverManager</code> umsetzen. Es wäre möglich, die <code>Driver</code>-_Auswahllogik_ (vgl. <code>java.sql.DriverManager.getConnection</code>) komplett im <code>buttle.jdbc.Driver</code> zu implementieren.</p>
<p>Dieses Vorgehen/Verfahren des <strong>erneuten Registrierens</strong> hat einige Schwächen:</p>
<p>Beim <strong>Deregistrieren</strong> teilt der <code>DriverManager</code> jeder <code>Driver</code> Instanz (abhängig davon, wie der jeweilige <code>Driver</code> registriert wurde) mit, dass sie gerade deregistriert wird. Dadurch kann es zu einer <strong>Zustandsänderung</strong> im <code>Driver</code> kommen. Zum Beispiel könnte es sein, dass der <code>Driver</code> beim Deregistrieren bestimmte Ressourcen freigibt.</p>
<p><em>Buttle</em> muss die <code>Driver</code> anschließend ja wieder registrieren (__re-registrieren__). Das kann <em>Buttle</em> nicht auf die gleiche Art und Weise machen, wie die ursprüngliche Registrierung erfolgt ist, denn <em>Buttle</em> weiß gar nicht, wie die <code>Driver</code> ursprünglich registriert wurden (zumal ein <code>Class.forName</code> nur einmal zum Laden einer Klasse und damit zum Ausführen der statischen Initialisierung führt).</p>
<p>Daher bleibt <em>Buttle</em> nichts weiter übrig, als <strong>dieselben</strong> <code>Driver</code> Instanzen, die <em>Buttle</em> zuvor gerade <strong>deregistriert</strong> hat, umgehend explizit selber wieder zu <strong>re-registrieren</strong>. Es kann nun aber sein, dass die <code>Driver</code> Instanzen ihren Zustand geändert haben (z.B. Ressourcen freigegeben haben) und in diesem Zustand gar nicht korrekt als registrierter <code>Driver</code> funktionieren können, weil sie für diesen Use-Case nie entworfen wurden.</p>
<p>Als weiteres Problem bleibt <code>java.sql.DriverManager.getDrivers()</code>. Diese Methode liefert alle registrierten <code>Driver</code>. Sollte die Anwendung diese Methode benutzen, um sich selber einen <em>passenden</em> <code>Driver</code> zu suchen, so würde sie auch die <em>echten</em> <code>Driver</code> (als <em>Kandidaten</em>) erhalten. Das kann oder kann nicht zu dem gewünschten Programmverhalten führen. Als <em>Lösung</em> könnte <em>Buttle</em> die <code>Driver</code> <strong>nicht</strong> wie oben beschrieben <em>re-registrieren</em> sondern stattdessen entweder</p>
<ul>
  <li>Proxys um die originalen <code>Driver</code> (re-)registrieren oder</li>
  <li>gar keine <code>Driver</code> (re-)registrieren, sondern die <em>Auswahllogik</em> wie  oben erwähnt selber intern implemetieren.</li>
</ul>
<p>In beiden Fällen bliebe aber dennoch ein letztes <code>getDrivers</code>-Problem: es ist möglich, dass ein <code>Driver</code> registriert wird, <strong>nachdem</strong> <em>Buttle</em> die vorhandenen/registrierten <code>Driver</code> re-registriert hat (denn dies geschieht ja nur einmalig, wenn <em>Buttle</em> registriert wird). <em>Buttle</em> kann zwar immer wieder, wenn er angesprochen wird, prüfen, ob seit der letzten/vorangegangenen Prüfung ein neuer <code>Driver</code> hinzugekommen ist und diese dann auch wie oben beschrieben ersetzen/re-registrieren. Aber es bleibt eine kleine Lücke, in der ein neuer <code>Driver</code> registriert wird und unmittelbar anschließend <code>getDrivers</code> aufgerufen wird. In so einem Szenario hat <em>Buttle</em> keine Möglichkeit, den neuen <code>Driver</code> zu ersetzen.</p>
<p><strong>Fazit:</strong> die Idee, dass eine Anwendung beim Einsatz von <em>Buttle</em> weiterhin eine JDBC-URL des <em>echten</em> JDBC-Treibers verwendet, wirft eine Menge Fragen und mögliche Problemsituationen auf.</p>
<p>Es sollte also wenn möglich auf diese Option verzichtet werden.</p>
<h2><a href="#zugriff-auf-echten-jdbc-treiber" name="zugriff-auf-echten-jdbc-treiber"></a>Zugriff auf echten JDBC-Treiber</h2>
<p>Da <em>Buttle</em> wie beschrieben die registrierten <code>Driver</code> alle im <code>DriverManager</code> belässt bzw. <em>re-registriert</em>, kann <em>Buttle</em> den <code>DriverManager</code> weiterhin dafür benutzen, zu einer <em>echten</em> JDBC-URL den <em>echten</em> Driver zu finden.</p>
<p>Dazu ruft <em>Buttle</em> einfach <code>java.sql.DriverManager.getDriver(&lt;jdbc-url&gt;)</code> auf und muss dann nur merken, wenn <em>Buttle</em> selber gerade vom <code>DriverManager</code> aufgerufen wurde - ansonsten würde es zu einer Endlosrekursion kommen.</p>
<p><em>Buttle</em> erhält somit vom <code>DriverManager</code> den <em>echten</em> <code>Driver</code> und kann selber einen <code>Driver</code>-Proxy zu diesem liefern.</p>
<h1><a href="#beispiele" name="beispiele"></a>Beispiele</h1>
<h1><a href="#notizen" name="notizen"></a>Notizen</h1>
<ul>
  <li>
  <p>Buttle erweitern</p></li>
  <li>
  <p>Buttle hacken</p></li>
  <li>
  <p>Driver Interface: was liefern die einzelnen Methoden?</p></li>
  <li>
  <p>Mehrere JDBC Verbindungen um verschiedene JDBC Verbindungen?</p></li>
  <li>
  <p>Buttle als XATreiber?</p></li>
  <li>
  <p>Buttle im App-Server vor einer DataSource?</p></li>
</ul></div></div></div></body></html>